<% c++ #include "../content.h" %>  
<% skin default_skin %>  
<% view samples_psum uses content::samples_psum extends samples %>  

<% template stuff() %>
  <p class="subtitle is-3 section-title">Computing prefix sums</p>
  <p class="has-text-justified">

  <article class="message is-warning">
  <div class="message-body">
  Given is an array of <code>A</code> of <i>n</i> integers, 
  such that <i>n</i> is power of two. The
  task is to produce a new array, <code>B</code>, that 
  the <i>i</i>-th element in <code>B</code> is the sum of the first <i>i</i> 
  elements in <code>A</code>.
  </div>
  </article>

  </p><p class="has-text-justified" style="padding-top:5px">
   A simple sequential implementation is as follows:
<pre class="codepre" data-id="psum_seq"><code class="wt">input int A[_];
int n = A.size;
output int B[n];

B[0] = A[0];

for (int i = 1; i < n; i++)
    B[i] = B[i - 1] + A[i];
</code></pre>

Both time and work of the previous algorithm are linear. We present two implementation
of parallel version with linear work and logarithmic time. The first one is a recursive
procedure:

<pre class="codepre" data-id="psum_rec"><code class="wt">input int A[_];
    output int B[A.size];

    int prefix_sums(int A[_], int B[_]) {
        if (A.size == 1) {
          B[0] = A[0];
          return 1;
        }

        int n = A.size / 2;
        int AA[n], BB[n];

        pardo(i : n) AA[i] = A[2 * i] + A[2 * i + 1];

        prefix_sums(AA, BB);

        pardo(i : n) {
            B[2 * i] = BB[i] - A[2 * i + 1];
            B[2 * i + 1] = BB[i];
        }

        return 1;
    }

    prefix_sums(A, B);
</code></pre>
The idea is to first collapse the input array by adding consecutive pairs of elements.
Recursively computing the prefix sums <code>BB</code> on the collapsed array 
<code>AA</code>, we get the
prefix sums of all even prefixes of <code>A</code>. Then it is easy to fill the odd prefixes
by subtracting the corresponding value from <code>A</code>.

  </p><p class="has-text-justified" style="padding-top:5px">
Another version is a bottom-up non-recursive algorithm. For clarity, we use an
auxiliary storage <code>B</code> with <i>n log n</i> elements (<i>log n</i> 
rows and <i>n</i> columns).
Note however, that we use only linearly many elements from <code>B</code>, so it is not
hard to rewrite the program such that it uses only linear storage.
The program works in two passes: in the bottom-up pass it adds the consecutive
pairs of elements in each row, and in the top-down pass it fills in
the elements on odd positions.

<pre class="codepre" data-id="psum_iter"><code class="wt">input int A[_];
int n = A.size;

int ln = 0;
for (; 2 ^ ln < n; ln++);

int B[ln + 1, n];
output int S[n];

pardo(i : n) B[0, i] = A[i];

for (int t = 0; 2 ^ t < n; t++)
    pardo(i : n / 2 ^ (t + 1))
        B[t + 1, i] = B[t, 2 * i] + B[t, 2 * i + 1];

for (int t = 0; 2 ^ t < n; t++)
    pardo(i : n / 2 ^ (ln - t)) {
        B[ln - t - 1, 2 * i] = B[ln - t, i] - B[ln - t - 1, 2 * i + 1];
        B[ln - t - 1, 2 * i + 1] = B[ln - t, i];
    }

pardo(i : n) S[i] = B[0, i];
</code></pre>      




<% end %>

<% end view %>  
<% end skin %>  
