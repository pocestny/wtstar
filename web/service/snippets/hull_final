/*
  computing upper convex hull
  */

type point { float x, y; }
  
float signed_triangle_area(point a, point b, point c) {
  return (
      (a.x * b.y - a.y * b.x + a.y * c.x - a.x * c.y + b.x * c.y - c.x * b.y) /
      2.0);
}

int dir_cw(point a, point b, point c) {
  return (signed_triangle_area(a, b, c) < -1e-15);
}
int dir_ccw(point a, point b, point c) {
  return (signed_triangle_area(a, b, c) > 1e-15);
}

input point A[_];
int n=A.size;
sort(A, point.x);

// hack to make x coordinate unique
pardo(i:n) A[i].x+=i*1e-6;

// test if from-P[i] is tangent to P[0]...P[P.size-1]
// from is to the left of P
// returns 0 if it is a tangent, -1 or 1 if the tangent point is 
// to the right or left on P
int test_hit_lr(point from, int i, point P[_]) {
  if (i<0) return -1;
  if (i>=P.size) return 1;
  if (P.size==1) return 0;
  if (i==0) {
    if (dir_cw(from,P[i],P[i+1])) return 0;
    return -1;
  }
  if (i==P.size-1) {
    if (!dir_ccw(from,P[i],P[i-1])) return 0;
    return 1;
  }
  if (dir_ccw(from, P[i], P[i-1])) return 1;
  if (!dir_cw(from, P[i], P[i + 1])) return -1;
  return 0;
}

// test if from-P[i] is tangent to P[0]...P[P.size-1]
// from is to the right of P
// returns 0 if it is a tangent, -1 or 1 if the tangent point is 
// to the right or left on P
int test_hit_rl(point from, int i, point P[_]) {
  if (i<0) return -1;
  if (i>=P.size) return 1;
  if (P.size==1) return 0;
  if (i==0) {
    if (dir_ccw(from,P[i],P[i+1])) return 0;
    return -1;
  }
  if (i==P.size-1) {
    if (!dir_cw(from,P[i],P[i-1])) return 0;
    return 1;
  }
  if (dir_cw(from, P[i], P[i-1])) return 1;
  if (!dir_ccw(from, P[i], P[i + 1])) return -1;
  return 0;
}


// find a tangent from from to P[0]...
// from is to the left of P[i]
int tangent_point_direct(point from, point P[_]) {
  int result = 0;
  int n = P.size;
  if (n < 2) return n - 1;
  pardo(i : P.size ) 
    if (test_hit_lr(from,i,P)==0)
      result = i;
  return result;
}

// use p-ary search to find the tangent
int tangent_point_p_ary(int l, int r, point from, point P[_], int p) {
  int n = r - l + 1;
  int result = -1;
  if (p>=n) {
    // we have enough processors to perform full search
    pardo(i:n) if (test_hit_lr(from,l+i,P)==0) result = l+i;
    return result;
  }
  // split the interval from l to r into p+1 parts
  // i-th processor checks the i-th interval; if noone succeedes, its the last one
  int q=n/(p+1);
  int bucket=-1;
  pardo(i:p) {
    int mypos = l + (i + 1) * q - 1;
    if (test_hit_lr(from,mypos,P)==0)
       result = mypos; // the boundary of the interval is exact hit
    else if (test_hit_lr(from,mypos,P)==1 && test_hit_lr(from,mypos-q,P)==-1   )
      bucket=mypos; // the correct interval was found
  }
  if (result != -1) return result;
  // recurse into the proper interval
  if (bucket == -1)
    return tangent_point_p_ary(l + p * q, r,from,P,p);
  else
    return tangent_point_p_ary(bucket - q + 1, bucket,from,P,p);

}


// returns size
int compute_hull(int l, int r) {
  int n = r - l + 1;
  if (n < 3) {
    // base
    return n;
  } else {
    int m = (r + l) / 2;
    // prepare two halves
    int ll[2], rr[2];
    ll[0] = l;     rr[0] = m;
    ll[1] = m + 1; rr[1] = r;
    int s[2];

    // divide and conquer
    pardo(i : 2) {s[i] = compute_hull(ll[i], rr[i]);}

    // the hulls are returned as flags in the inHull array,
    // lets copy the indices of hull points into HL and HR
    point HL[s[0]], HR[s[1]];
    int tl, tr;
    
    pardo(i:s[0]) HL[i]=A[ll[0]+i];
    pardo(i:s[1]) HR[i]=A[ll[1]+i];


    // if HL is small, find the tangent by brute force
    if (s[0]<9){ 
      pardo(i : s[0]) {
        // find a tangent from HL[i] to HR
        int t = tangent_point_p_ary(0,HR.size-1,HL[i],HR,sqrt(HR.size));
        // if it also a tangent from HR[t] to HL, we have the result
        if (test_hit_rl(HR[t],i,HL)==0) {
          tl=i;tr=t;
        }
      }
    }
    else {   
      // partition into sqrt intervals
      int sn = sqrt(s[0])-1;
      int hits[sn];
      int result=-1;
      int li = (sn-1)*sn, ri=s[0]-1;
      pardo (i:sn-1) {
        // fint the tangents for boundaries of intervals
        int j = (i+1)*sn;
        int  t = tangent_point_p_ary(0,HR.size-1,HL[j],HR,sqrt(HR.size));
        int hit = test_hit_rl(HR[t],j,HL);
        hits[i]=hit;
        if (hit==0) {
          // direct hit, we have the result
          result=j; tl=j;tr=t;
        }
        if (hit==1) {
          // this point is to the right and the previous is to the left (or does not exist)
          // we have found the proper bucket
          if (i==0) {li=0;ri=sn;}
          else if (hits[i-1]==-1) {li=i*sn;ri=(i+1)*sn;}
        }
      } 
      // if there wasn't adirect hit, 
      // check the found interval by brute force
      if (result==-1)
      pardo(i : ri-li+1) {
        int t = tangent_point_p_ary(0,HR.size-1,HL[li+i],HR,HR.size);
        if (test_hit_rl(HR[t],li+i,HL)==0) {tl=li+i;tr=t;}
      }
    }
    pardo(i:tl+1) A[l+i]=HL[i];
    pardo(i:s[1]-tr) A[l+tl+1+i]=HR[tr+i];

    return tl + 1 + s[1] - tr;
  }
}


output int q = compute_hull(0, n - 1);

// finally, assemble the output
output point H[q];
pardo(i : q)  H[i] = A[i];


