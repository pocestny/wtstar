/*
   merge
   input: two sorted sequences of distinct integers of length n
   output: merged sequence
   T = O(log n)
   W = O(n)
*/

// number of items strictly smaller than y
int binary_search(int y, int A[_]) {
  int n = A.size;
  int l = 0, r = n - 1;
  while (l <= r) {
    int m = (l + r) / 2;
    if (A[m] < y)
      l = m + 1;
    else if (A[m] > y)
      r = m - 1;
    else
      return m;
  }
  return l;
}

input int A[_], B[_];
int n = A.size, m = B.size;
output int C[n + m];
int bs = log(n);

int merge(int A[_], int B[_], int offs) {
  int n = A.size, m = B.size;

  // if sizes are small, just merge sequentially
  if (A.size <= bs && B.size <= bs) {
    int i = 0, j = 0, k = offs;

    while (i < n || j < m)
      if (i == n)
        C[k++] = B[j++];
      else if (j == m)
        C[k++] = A[i++];
      else if (A[i] < B[j])
        C[k++] = A[i++];
      else
        C[k++] = B[j++];
  } else {
    int k = 1 + (n - 1) / bs;
    int X[k];
    pardo(i : k) X[i] = binary_search(A[i * bs], B);

    // copy elemets from B smaller than any of A
    if (X[0] > 0) pardo(i : X[0]) C[i + offs] = B[i];

    pardo(i : k) {
      int nn = bs;
      if (i == k - 1) nn = n - i * bs;
      int AA[nn];
      pardo(j : nn) AA[j] = A[i * bs + j];

      int top = m;
      if (i < k - 1) top = X[i + 1];
      int mm = top - X[i];
        
      if (mm == 0) 
        pardo(j : nn) C[offs + i * bs + j + X[i]] = AA[j];
      else {
        int BB[mm];
        pardo(j : mm) BB[j] = B[X[i] + j];
        merge(BB, AA, offs + i * bs + X[i]);
      }
    }
  }
}

merge(A,B,0);
