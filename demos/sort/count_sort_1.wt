/*
   input: k, and an array of integers a_1,...,a_n from 1...k (length power of 2)
   output: sorted array

   T = O(log n)
   W = O(k n)
*/

input int k, A[_];
int n = A.size;

output int B[n];
int Cnt[k], ps[k + 1];

//////////////////////////////////////////////
// compute the number of occurences of val in X (length power of 2)
// T=O(log n)
// W=O(n)
int count(int val, int X[_]) {
  int n = X.size, tmp[n];

  pardo(i : n) if (X[i] == val) tmp[i] = 1;
  else tmp[i] = 0;
  // compute the sum
  for (int t = 0; 2 ^ t < n; t++)
    pardo(i : n / 2 ^ (t + 1)) tmp[i] = tmp[2 * i] + tmp[2 * i + 1];
  return tmp[0];
}

//////////////////////////////////////////////
// prefix sums
int prefix_sum(int A[_], int S[_]) {
  int n = A.size;
  int ln = 0;
  for (; 2 ^ ln < n; ln++);

  int B[ln + 1, n];  // storage

  // copy input
  pardo(i : n) B[0, i] = A[i];

  // bottom-up traversal
  for (int t = 0; 2 ^ t < n; t++)
    pardo(i : n / 2 ^ (t + 1)) B[t + 1, i] = B[t, 2 * i] + B[t, 2 * i + 1];

  // top-down traversal
  for (int t = 0; 2 ^ t < n; t++) pardo(i : n / 2 ^ (ln - t)) {
      B[ln - t - 1, 2 * i] = B[ln - t, i] - B[ln - t - 1, 2 * i + 1];
      B[ln - t - 1, 2 * i + 1] = B[ln - t, i];
    }

  // write output
  S[0] = 0;
  pardo(i : n) S[i + 1] = B[0, i];
  return 0;
}

//////////////////////////////////////////////
// main code

pardo(i : k) Cnt[i] = count(i, A);
prefix_sum(Cnt, ps);

pardo(i : k) pardo(j : Cnt[i]) B[ps[i] + j] = i;
