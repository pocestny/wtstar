/* 

non-recursive prefix sums with additional O(n log n) memory 

input:  array of integers (length power of 2)
output: array of prefix sums

T = O(log n)
W = O(n)

*/

input int A[_];
int n = A.size;

// log should be built in
int ln = 0;
for (; 2 ^ ln < n; ln++);

int B[ln + 1, n]; // storage

output int S[n];

// copy input
pardo(i : n) B[0, i] = A[i];

// bottom-up traversal
for (int t = 0; 2 ^ t < n; t++)
  pardo(i : n / 2 ^ (t + 1)) 
      B[t + 1, i] = B[t, 2 * i] + B[t, 2 * i + 1];

// top-down traversal
for (int t = 0; 2 ^ t < n; t++) 
    pardo(i : n / 2 ^ (ln - t)) {
        B[ln - t - 1, 2 * i] = B[ln - t, i] - B[ln - t - 1, 2 * i + 1];
        B[ln - t - 1, 2 * i + 1] = B[ln - t, i];
    } 

// write output
pardo(i : n) S[i] = B[0, i];
