
// ceiling log
int log2(int n) {
  int ln=0;
  for (; 2 ^ ln < n; ln++);
  return ln;
}

// sum using balanced tree computation
// T = O(log n)
// W = O(n)
int sum(int A[_]) {
  int n = 2^log2(A.size),Y[n];
  pardo(i:n) Y[i]=0;
  pardo(i:A.size) Y[i]=A[i];

  for (int t = 0; 2 ^ t < n; t++)
    pardo(i : n / 2 ^ (t + 1)) 
      Y[i] = Y[2 * i] + Y[2 * i + 1];

  return Y[0];
}

// nonrecursive prefix sums 
// T = O(log n)
// W = O(n)
// [ additional O(n log n) memory ]
int prefix_sums(int A[_], int S[_]) {
  int n = 2^log2(A.size), ln=log2(n);

  int B[ln+1, n];  // storage

  // copy input
  pardo(i : n) B[0, i] = 0;
  pardo(i : A.size) B[0,i] = A[i];

  // bottom-up traversal
  for (int t = 0; 2 ^ t < n; t++)
    pardo(i : n / 2 ^ (t + 1)) B[t + 1, i] = B[t, 2 * i] + B[t, 2 * i + 1];

  // top-down traversal
  for (int t = 0; 2 ^ t < n; t++) pardo(i : n / 2 ^ (ln - t)) {
      B[ln - t - 1, 2 * i] = B[ln - t, i] - B[ln - t - 1, 2 * i + 1];
      B[ln - t - 1, 2 * i + 1] = B[ln - t, i];
    }

  // write output
  pardo(i : A.size) S[i] = B[0, i];
  return 0;
}



// compute the number of occurences of val in X
// T=O(log n)
// W=O(n)
int count(int val, int X[_]) {
  int n = X.size, tmp[n];

  pardo(i : n) 
    if (X[i] == val) tmp[i] = 1;
    else tmp[i] = 0;
  return sum(tmp);  
}


