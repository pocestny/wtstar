#include "utils/geometry.wt"
#include "utils/max.wt"
#include "utils/prefix_sums.wt"

input point A[_];
int n=A.size;
sort(A, point.x);

// hack to make x coordinate unique
pardo(i:n) A[i].x+=i*1e-6;

// flags for points contained in the hull
int inHull[n];

// copy into H the points from the range l..r in inHull 
void copy_hull(int H[_], int l, int r) {
  int n = r - l + 1, A[n], ps[n];
  pardo(i : n) A[i] = inHull[l + i];
  prefix_sums(A, ps);
  pardo(i : n)  if (inHull[l + i]) H[ps[i] - 1] = l + i;
}

// test if A[from]-A[p[i]] is tangent to A[P[0]]...A[P[P.size-1]]
// A[from] is to the left of P
// returns 0 if it is a tangent, -1 or 1 if the tangent point is 
// to the right or left on P
int test_hit_lr(int from, int i, int P[_]) {
  if (i<0) return -1;
  if (i>=P.size) return 1;
  if (P.size==1) return 0;
  if (i==0) {
    if (dir_cw(A[from],A[P[i]],A[P[i+1]])) return 0;
    return -1;
  }
  if (i==P.size-1) {
    if (!dir_ccw(A[from],A[P[i]],A[P[i-1]])) return 0;
    return 1;
  }
  if (dir_ccw(A[from], A[P[i]], A[P[i-1]])) return 1;
  if (!dir_cw(A[from], A[P[i]], A[P[i + 1]])) return -1;
  return 0;
}

// test if A[from]-A[p[i]] is tangent to A[P[0]]...A[P[P.size-1]]
// A[from] is to the right of P
// returns 0 if it is a tangent, -1 or 1 if the tangent point is 
// to the right or left on P
int test_hit_rl(int from, int i, int P[_]) {
  if (i<0) return -1;
  if (i>=P.size) return 1;
  if (P.size==1) return 0;
  if (i==0) {
    if (dir_ccw(A[from],A[P[i]],A[P[i+1]])) return 0;
    return -1;
  }
  if (i==P.size-1) {
    if (!dir_cw(A[from],A[P[i]],A[P[i-1]])) return 0;
    return 1;
  }
  if (dir_cw(A[from], A[P[i]], A[P[i-1]])) return 1;
  if (!dir_ccw(A[from], A[P[i]], A[P[i + 1]])) return -1;
  return 0;
}


// find a tangent from A[from] to A[P[0]]...
// A[from] is to the left of A[P[i]]
int tangent_point_direct(int from, int P[_]) {
  int result = 0;
  int n = P.size;
  if (n < 2) return n - 1;
  pardo(i : P.size ) 
    if (test_hit_lr(from,i,P)==0)
      result = i;
  return result;
}

// use p-ary search to find the tangent
int tangent_point_p_ary(int l, int r, int from, int P[_], int p) {
  int n = r - l + 1;
  int result = -1;
  if (p>=n) {
    // we have enough processors to perform full search
    pardo(i:n) if (test_hit_lr(from,l+i,P)==0) result = l+i;
    return result;
  }
  // split the interval from l to r into p+1 parts
  // i-th processor checks the i-th interval; if noone succeedes, its the last one
  int q=n/(p+1);
  int bucket=-1;
  pardo(i:p) {
    int mypos = l + (i + 1) * q - 1;
    if (test_hit_lr(from,mypos,P)==0)
       result = mypos; // the boundary of the interval is exact hit
    else if (test_hit_lr(from,mypos,P)==1 && test_hit_lr(from,mypos-q,P)==-1   )
      bucket=mypos; // the correct interval was found
  }
  if (result != -1) return result;
  // recurse into the proper interval
  if (bucket == -1)
    return tangent_point_p_ary(l + p * q, r,from,P,p);
  else
    return tangent_point_p_ary(bucket - q + 1, bucket,from,P,p);

}


// returns size
int compute_hull(int l, int r) {
  int n = r - l + 1;
  if (n < 3) {
    // base
    pardo(i : n) inHull[l + i] = 1;
    return n;
  } else {
    int m = (r + l) / 2;
    // prepare two halves
    int ll[2], rr[2];
    ll[0] = l;     rr[0] = m;
    ll[1] = m + 1; rr[1] = r;
    int s[2];

    // divide and conquer
    pardo(i : 2) s[i] = compute_hull(ll[i], rr[i]);

    // the hulls are returned as flags in the inHull array,
    // lets copy the indices of hull points into HL and HR
    int HL[s[0]], HR[s[1]];
    int tl, tr;
    
    copy_hull(HL, ll[0], rr[0]);
    copy_hull(HR, ll[1], rr[1]);

    // if HL is small, find the tangent by brute force
    if (s[0]<9){ 
      pardo(i : s[0]) {
        // find a tangent from HL[i] to HR
        int t = tangent_point_p_ary(0,HR.size-1,HL[i],HR,sqrt(HR.size));
        // if it also a tangent from HR[t] to HL, we have the result
        if (test_hit_rl(HR[t],i,HL)==0) {
          tl=i;tr=t;
        }
      }
    }
    else {   
      // partition into sqrt intervals
      int sn = sqrt(s[0])-1;
      int hits[sn];
      int result=-1;
      int li = (sn-1)*sn, ri=s[0]-1;
      pardo (i:sn-1) {
        // fint the tangents for boundaries of intervals
        int j = (i+1)*sn;
        int  t = tangent_point_p_ary(0,HR.size-1,HL[j],HR,sqrt(HR.size));
        int hit = test_hit_rl(HR[t],j,HL);
        hits[i]=hit;
        if (hit==0) {
          // direct hit, we have the result
          result=j; tl=j;tr=t;
        }
        if (hit==1) {
          // this point is to the right and the previous is to the left (or does not exist)
          // we have found the proper bucket
          if (i==0) {li=0;ri=sn;}
          else if (hits[i-1]==-1) {li=i*sn;ri=(i+1)*sn;}
        }
      } 
      // if there wasn't adirect hit, 
      // check the found interval by brute force
      if (result==-1)
      pardo(i : ri-li+1) {
        int t = tangent_point_p_ary(0,HR.size-1,HL[li+i],HR,HR.size);
        if (test_hit_rl(HR[t],li+i,HL)==0) {tl=li+i;tr=t;}
      }
    }

    // zero-out the parts that are not in hull 
    if (s[0] - tl > 1) pardo(i : s[0] - 1 - tl) 
      inHull[HL[i + tl + 1]] = 0;
    if (tr > 0) pardo(i : tr) 
      inHull[HR[i]] = 0;
    return tl + 1 + s[1] - tr;
  }
}

output int q = compute_hull(0, n - 1);
int ps[n];

// finally, assemble the output
prefix_sums(inHull, ps);
output point H[ps[n - 1]];
pardo(i : n) if (inHull[i]) H[ps[i] - 1] = A[i];


